<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Cyprien Vittoz Portfolio</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link href="assets/css/prism.css" rel="stylesheet" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="index.html" class="logo">Cyprien C. Vittoz</a>
					</header>

				<!-- Nav -->
				<nav id="nav">
					<ul class="links">
						<li class="active"><a href="index.html#header">Python Projects</a></li>
						<li><a href="R_index.html#header">R Projects</a></li>
						<li class="right-aligned"><a href="About_me.html#header">About Me</a></li>
					</ul>
					<ul class="icons">
						<li><a href="https://www.linkedin.com/in/vittozcyprien/" class="icon brands fa-linkedin" target="_blank"><span class="label">LinkedIn</span></a></li>
					</ul>
				</nav>

				<!-- Main -->
					<div id="main">
					
						<ul class="actions" style="display: flex; justify-content: space-between; width: 100%;">
							<li><a href="index.html#nav" class="button small">< Other Python Projects</a></li>
							<li><a href="" class="button small">Same Project in R ></a></li>
						</ul>						

						<!-- Post -->
							<section class="post">
								<header class="major">
									<h2>Mushroom Toxicity Predictor</h2>
									<p>In this project, we will implement a random forest classifier in Python to predict the toxicity of mushrooms 
										based on their characteristics and build a web application to make the model accessible to users.
									</p>
								</header>
								<div class="image main"><img src="images/mushroom2.jpg" alt="" /></div>
								<ul class="actions">
									<li><a href="#intromushp" class="button small">Introduction</a></li>
									<li><a href="#datamushp" class="button small">Data</a></li>
									<li><a href="#vizmushp" class="button small">Exploration</a></li>
									<li><a href="#descmushp" class="button small">Model</a></li>
									<li><a href="#webmushp" class="button small">Web App</a></li>
								</ul>
								<hr />
								<h3 id="intromushp">Introduction</h3>
								<p>Before delving into this project, it's important to clarify what we aim to achieve and the means by which we plan to do so. Imagine being lost in a forest
									 or locked inside a laboratory with a bunch of mushrooms. In the first few days, we might survive on the water from the mushrooms, but eventually, we will 
									 need to eat them. The problem is that some mushrooms are toxic and could harm or kill us. Therefore, we need to find a way to differentiate between toxic 
									 and non-toxic mushrooms. However, large databases may not be useful if you don't know the name of the mushroom you're looking for, and you may also lack 
									 access to the internet.
								</p>
								<p>
									To solve this problem and help people who might find themselves in such a situation, we can develop a machine learning model, implement it in an application, 
									and make it accessible to everyone. For practicality, this will be presented as a web application, but the app can easily be downloaded and used offline.
								</p>
								<hr />
								<h3 id="datamushp">Data</h3>
								<p>
									The data used in this project is the <a href="https://archive.ics.uci.edu/dataset/73/mushroom" target="_blank">Mushroom Classification</a> dataset from UCI 
									Machine Learning Repository. It includes descriptions of gilled mushroom species in the Agaricus and Lepiota families, first documented in 
									<a href="https://www.amazon.com/National-Audubon-Society-American-Mushrooms/dp/0394519922" target="_blank">The Audubon 
										Society Field Guide to North American Mushrooms (1981)</a> from G.H. Lincoff.

									This dataset contains 8124 rows and 22 columns which look like this after removing the NA values:
								</p>

								<div id="tab-container-1" class="tab-container">
									<div class="tabs">
										<button class="tab-link" onclick="openTab(event, 'Content1','tab-container-1')">Table</button>
										<button class="tab-link" onclick="openTab(event, 'Content2','tab-container-1')">Code</button>
									</div>
								
									<div id="Content1" class="tab-content">
										<div class="table-wrapper">
											<table  class="alt">
													<tr>
													  <th>cap-shape</th>
													  <th>cap-surface</th>
													  <th>cap-color</th>
													  <th>bruises</th>
													  <th>odor</th>
													  <th>gill-attachment</th>
													  <th>gill-spacing</th>
													  <th>gill-size</th>
													  <th>gill-color</th>
													  <th>stalk-shape</th>
													  <th>stalk-root</th>
													  <th>stalk-surface-above-ring</th>
													  <th>stalk-surface-below-ring</th>
													  <th>stalk-color-above-ring</th>
													  <th>stalk-color-below-ring</th>
													  <th>veil-type</th>
													  <th>veil-color</th>
													  <th>ring-number</th>
													  <th>ring-type</th>
													  <th>spore-print-color</th>
													  <th>population</th>
													  <th>habitat</th>
													</tr>
													<tr>
													  <td>x</td>
													  <td>s</td>
													  <td>n</td>
													  <td>t</td>
													  <td>p</td>
													  <td>f</td>
													  <td>c</td>
													  <td>n</td>
													  <td>k</td>
													  <td>e</td>
													  <td>e</td>
													  <td>s</td>
													  <td>s</td>
													  <td>w</td>
													  <td>w</td>
													  <td>p</td>
													  <td>w</td>
													  <td>o</td>
													  <td>p</td>
													  <td>k</td>
													  <td>s</td>
													  <td>u</td>
													</tr>
													<tr>
													  <td>x</td>
													  <td>s</td>
													  <td>y</td>
													  <td>t</td>
													  <td>a</td>
													  <td>f</td>
													  <td>c</td>
													  <td>b</td>
													  <td>k</td>
													  <td>e</td>
													  <td>c</td>
													  <td>s</td>
													  <td>s</td>
													  <td>w</td>
													  <td>w</td>
													  <td>p</td>
													  <td>w</td>
													  <td>o</td>
													  <td>p</td>
													  <td>n</td>
													  <td>n</td>
													  <td>g</td>
													</tr>
													<tr>
													  <td>b</td>
													  <td>s</td>
													  <td>w</td>
													  <td>t</td>
													  <td>l</td>
													  <td>f</td>
													  <td>c</td>
													  <td>b</td>
													  <td>n</td>
													  <td>e</td>
													  <td>c</td>
													  <td>s</td>
													  <td>s</td>
													  <td>w</td>
													  <td>w</td>
													  <td>p</td>
													  <td>w</td>
													  <td>o</td>
													  <td>p</td>
													  <td>n</td>
													  <td>n</td>
													  <td>m</td>
													</tr>
													<tr>
													  <td>x</td>
													  <td>y</td>
													  <td>w</td>
													  <td>t</td>
													  <td>p</td>
													  <td>f</td>
													  <td>c</td>
													  <td>n</td>
													  <td>n</td>
													  <td>e</td>
													  <td>e</td>
													  <td>s</td>
													  <td>s</td>
													  <td>w</td>
													  <td>w</td>
													  <td>p</td>
													  <td>w</td>
													  <td>o</td>
													  <td>p</td>
													  <td>k</td>
													  <td>s</td>
													  <td>u</td>
													</tr>
													<tr>
													  <td>x</td>
													  <td>s</td>
													  <td>g</td>
													  <td>f</td>
													  <td>n</td>
													  <td>f</td>
													  <td>w</td>
													  <td>b</td>
													  <td>k</td>
													  <td>t</td>
													  <td>e</td>
													  <td>s</td>
													  <td>s</td>
													  <td>w</td>
													  <td>w</td>
													  <td>p</td>
													  <td>w</td>
													  <td>o</td>
													  <td>e</td>
													  <td>n</td>
													  <td>a</td>
													  <td>g</td>
													</tr>
											</table>
											<pre><code>Shape of y: (5644, 1)
Shape of X: (5644, 22)</code></pre>
											
										</div>
									</div>
								
									<div id="Content2" class="tab-content">
								
										<pre class="language-python"><code>import pandas as pd
# Fetch the mushroom dataset 
from ucimlrepo import fetch_ucirepo 
mushroom = fetch_ucirepo(id=73) 

# data (as pandas dataframes) 
X = mushroom.data.features 
y = mushroom.data.targets

X = X.dropna()
y = y.loc[X.index] # ensure that the same data are removed from X and y

pd.set_option('display.max_columns', None)
print("Shape of y:", y.shape)
print("Shape of X:", X.shape)
display(X)


										</code></pre>
								
									</div>
									</div>
									<br />
									<p>The new table contains 5644 individuals once NA values are removed. As you may notice, the dataset contains only discrete, non-ordered values but that are coded with letters. It lacks clarity, and our next step is to
										convert these letters into words. This is where the downloadable file <a href="https://archive.ics.uci.edu/dataset/73/mushroom" target="_blank">agaricus-lepiota.names</a> 
										(renamed afterward agaricus-lepiota.txt as a copy that only features the relevant section) provided by the UCI Repository comes handy.	For example, 
										we can read in it: <br><br>
										<i>" 1. cap-shape: bell=b, conical=c, convex=x, flat=f, knobbed=k, sunken=s"</i><br><br>
										We will first list for each column the possible values and their corresponding words. Then we can replace the coded values with their proper words.
								   </p>

								   <div id="tab-container-2" class="tab-container">
									<div class="tabs">
										<button class="tab-link" onclick="openTab(event, 'Content3', 'tab-container-2')">Table</button>
										<button class="tab-link" onclick="openTab(event, 'Content4', 'tab-container-2')">Code</button>
									</div>
								
									<div id="Content3" class="tab-content">
										<div class="table-wrapper">
											<table class="alt">
												<tr>
												  <th>Letter</th>
												  <th>poisonous</th>
												  <th>cap-shape</th>
												  <th>cap-surface</th>
												  <th>cap-color</th>
												  <th>bruises</th>
												  <th>odor</th>
												  <th>gill-attachment</th>
												  <th>gill-spacing</th>
												  <th>gill-size</th>
												  <th>gill-color</th>
												  <th>stalk-shape</th>
												  <th>stalk-root</th>
												  <th>stalk-surface-above-ring</th>
												  <th>stalk-surface-below-ring</th>
												  <th>stalk-color-above-ring</th>
												  <th>stalk-color-below-ring</th>
												  <th>veil-type</th>
												  <th>veil-color</th>
												  <th>ring-number</th>
												  <th>ring-type</th>
												  <th>spore-print-color</th>
												  <th>population</th>
												  <th>habitat</th>
												</tr>
												<tr>
												  <td>a</td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td>almond</td>
												  <td>attached</td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td>abundant</td>
												  <td></td>
												</tr>
												<tr>
												  <td>b</td>
												  <td></td>
												  <td>bell</td>
												  <td></td>
												  <td>buff</td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td>broad</td>
												  <td>buff</td>
												  <td></td>
												  <td>bulbous</td>
												  <td></td>
												  <td></td>
												  <td>buff</td>
												  <td>buff</td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td>buff</td>
												  <td></td>
												  <td></td>
												</tr>
												<tr>
												  <td>c</td>
												  <td></td>
												  <td>conical</td>
												  <td></td>
												  <td>cinnamon</td>
												  <td></td>
												  <td>creosote</td>
												  <td></td>
												  <td>close</td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td>club</td>
												  <td></td>
												  <td></td>
												  <td>cinnamon</td>
												  <td>cinnamon</td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td>cobwebby</td>
												  <td></td>
												  <td>clustered</td>
												  <td></td>
												</tr>
												<tr>
												  <td>d</td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td>descending</td>
												  <td>distant</td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td></td>
												  <td>woods</td>
												</tr>
												<tr>
													<td>e</td>
													<td>edible</td>
													<td></td>
													<td></td>
													<td>red</td>
													<td></td>
													<td></td>
													<td></td>
													<td></td>
													<td></td>
													<td>red</td>
													<td>enlarging</td>
													<td>equal</td>
													<td></td>
													<td></td>
													<td>red</td>
													<td>red</td>
													<td></td>
													<td></td>
													<td></td>
													<td>evanescent</td>
													<td></td>
													<td></td>
													<td></td>
												  </tr>
											  </table>
											  
												</div>
											</div>
										
											<div id="Content4" class="tab-content">
												<pre class="language-python"><code>import re

#Read the text file as a string
with open('agaricus-lepiota.txt', 'r') as file:
    content = file.read()

#Extract variable names and word-letter pairs
variables = []
word_letter_pairs = {}

#Regular expression to match variable names and their mappings
variable_pattern = re.compile(r'\d+\.\s*([^:]+):\s*([\s\S]+?)(?=\d+\.|$)')
mapping_pattern = re.compile(r'(\w+)=([a-z?])')

#Extracting each variable section
for match in variable_pattern.finditer(content):
    variable_name = match.group(1).strip()
    variables.append(variable_name)
    
    mappings = mapping_pattern.findall(match.group(2))
    for word, letter in mappings:
        if letter not in word_letter_pairs:
            word_letter_pairs[letter] = {}
        word_letter_pairs[letter][variable_name] = word

#Create a DataFrame
code_matrix = pd.DataFrame(word_letter_pairs).T
code_matrix = code_matrix.fillna('')
code_matrix = code_matrix.reindex(sorted(code_matrix.index), axis=0)
code_matrix = code_matrix[variables]

display(code_matrix.head())
												</code></pre>
										
											</div>
											</div>
											<br>
											<br>
											<p>Now we can apply these transformations to the dataset itself:</p>
											<div id="tab-container-3" class="tab-container">
												<div class="tabs">
													<button class="tab-link" onclick="openTab(event, 'Content5', 'tab-container-3')">Table</button>
													<button class="tab-link" onclick="openTab(event, 'Content6', 'tab-container-3')">Code</button>
												</div>
											
												<div id="Content5" class="tab-content">
													<div class="table-wrapper">
														<table class="alt">
																<tr>
																	<th>cap-shape</th>
																	<th>cap-surface</th>
																	<th>cap-color</th>
																	<th>bruises</th>
																	<th>odor</th>
																	<th>gill-attachment</th>
																	<th>gill-spacing</th>
																	<th>gill-size</th>
																	<th>gill-color</th>
																	<th>stalk-shape</th>
																	<th>stalk-root</th>
																	<th>stalk-surface-above-ring</th>
																	<th>stalk-surface-below-ring</th>
																	<th>stalk-color-above-ring</th>
																	<th>stalk-color-below-ring</th>
																	<th>veil-type</th>
																	<th>veil-color</th>
																	<th>ring-number</th>
																	<th>ring-type</th>
																	<th>spore-print-color</th>
																	<th>population</th>
																	<th>habitat</th>
																</tr>
															</thead>
															<tbody>
																<tr>
																	<td>convex</td>
																	<td>smooth</td>
																	<td>brown</td>
																	<td>bruises</td>
																	<td>pungent</td>
																	<td>free</td>
																	<td>close</td>
																	<td>narrow</td>
																	<td>black</td>
																	<td>enlarging</td>
																	<td>equal</td>
																	<td>smooth</td>
																	<td>smooth</td>
																	<td>white</td>
																	<td>white</td>
																	<td>partial</td>
																	<td>white</td>
																	<td>one</td>
																	<td>pendant</td>
																	<td>black</td>
																	<td>scattered</td>
																	<td>urban</td>
																</tr>
																<tr>
																	<td>convex</td>
																	<td>smooth</td>
																	<td>yellow</td>
																	<td>bruises</td>
																	<td>almond</td>
																	<td>free</td>
																	<td>close</td>
																	<td>broad</td>
																	<td>black</td>
																	<td>enlarging</td>
																	<td>club</td>
																	<td>smooth</td>
																	<td>smooth</td>
																	<td>white</td>
																	<td>white</td>
																	<td>partial</td>
																	<td>white</td>
																	<td>one</td>
																	<td>pendant</td>
																	<td>brown</td>
																	<td>numerous</td>
																	<td>grasses</td>
																</tr>
																<tr>
																	<td>bell</td>
																	<td>smooth</td>
																	<td>white</td>
																	<td>bruises</td>
																	<td>anise</td>
																	<td>free</td>
																	<td>close</td>
																	<td>broad</td>
																	<td>brown</td>
																	<td>enlarging</td>
																	<td>club</td>
																	<td>smooth</td>
																	<td>smooth</td>
																	<td>white</td>
																	<td>white</td>
																	<td>partial</td>
																	<td>white</td>
																	<td>one</td>
																	<td>pendant</td>
																	<td>brown</td>
																	<td>numerous</td>
																	<td>meadows</td>
																</tr>
																<tr>
																	<td>convex</td>
																	<td>scaly</td>
																	<td>white</td>
																	<td>bruises</td>
																	<td>pungent</td>
																	<td>free</td>
																	<td>close</td>
																	<td>narrow</td>
																	<td>brown</td>
																	<td>enlarging</td>
																	<td>equal</td>
																	<td>smooth</td>
																	<td>smooth</td>
																	<td>white</td>
																	<td>white</td>
																	<td>partial</td>
																	<td>white</td>
																	<td>one</td>
																	<td>pendant</td>
																	<td>black</td>
																	<td>scattered</td>
																	<td>urban</td>
																</tr>
																<tr>
																	<td>convex</td>
																	<td>smooth</td>
																	<td>gray</td>
																	<td>no</td>
																	<td>none</td>
																	<td>free</td>
																	<td>crowded</td>
																	<td>broad</td>
																	<td>black</td>
																	<td>tapering</td>
																	<td>equal</td>
																	<td>smooth</td>
																	<td>smooth</td>
																	<td>white</td>
																	<td>white</td>
																	<td>partial</td>
																	<td>white</td>
																	<td>one</td>
																	<td>evanescent</td>
																	<td>brown</td>
																	<td>abundant</td>
																	<td>grasses</td>
																</tr>
															</tbody>
														</table>
														<p><i>Note: At this point the predicted variable y , in the second dataset has also been converted (cf. code snippets for more information)</i></p>
													</div>
												</div>
											
												<div id="Content6" class="tab-content">
													<pre class="language-python">
<code>def transform_dataframe(X, code_matrix):
	transformed_X = pd.DataFrame(index=X.index, columns=X.columns)
    
    for col in X.columns:
        for idx in X.index:
            letter = X.at[idx, col]
            try:
                word = code_matrix.at[letter, col]
            except KeyError:
                raise KeyError(f"Error: The letter '{letter}' in column '{col}' was not found in code_matrix.")
            transformed_X.at[idx, col] = word
    
    return transformed_X

X = transform_dataframe(X, code_matrix)
y = transform_dataframe(y, code_matrix) # This is not necessary immediately but this way the predicted variable are also in words

display(X.head())
											</code></pre>
										</div>
									</div>
									<br>
									<p>This concludes this section. Now that we have a readable dataset, we can proceed to visualizing what kind of data we are dealing with.</p>
									<hr />
									<h3 id="vizmushp">Data Exploration</h3>

									<p>
										Given the large number of variables (22), it is quite complex to observe all their relationships. Therefore, we will simplify our search 
										for patterns within the dataset by reducing the number of dimensions. To this end, we will use the Multiple Correspondence Analysis (MCA) 
										method. MCA is a dimensionality reduction technique particularly useful for categorical data. It allows us to visualize the relationships 
										between different categories in our dataset. In this case, we will use MCA to visualize the relationships between different mushroom 
										characteristics and observe if they form a pattern in relation to their toxicity.
									</p>

									<div id="tab-container-4" class="tab-container">
										<div class="tabs">
											<button class="tab-link" onclick="openTab(event, 'Content7', 'tab-container-4')">Graph</button>
											<button class="tab-link" onclick="openTab(event, 'Content8', 'tab-container-4')">Code</button>
										</div>
									
										<div id="Content7" class="tab-content">
											<img src="images/mushmcap.jpg" alt="MCA Plot"  style="height:100%;">
										</div>
									
										<div id="Content8" class="tab-content">
											<pre class="language-python">
<code>import seaborn as sns
import matplotlib.pyplot as plt
import prince

# Convert all columns to 'category' type to ensure they are treated as categorical
df = pd.concat([X, y], axis=1)
for col in df.columns:
    df[col] = df[col].astype('category')

# Perform MCA with 3 dimensions
mca = prince.MCA(
    n_components=3,
    n_iter=3,
    copy=True,
    check_input=True,
    engine='sklearn',
    random_state=42
)

# Fit the model on the data excluding the 'poisonous' column
mca = mca.fit(df.drop(columns=['poisonous']))
mca_data = mca.transform(df.drop(columns=['poisonous']))
mca_data['poisonous'] = df['poisonous'].values

# Create a figure with two subplots side by side
fig, axes = plt.subplots(1, 2, figsize=(20, 8))

# Plot the MCA results for dimensions 1 and 2 on the first subplot
sns.scatterplot(
    ax=axes[0],
    x=mca_data[0],
    y=mca_data[1],
    hue=mca_data['poisonous'],
    palette=['green', 'red'],
    s=100,
    alpha=0.4
)
axes[0].set_xlabel('Dimension 1')
axes[0].set_ylabel('Dimension 2')
axes[0].legend().remove() 
axes[0].grid(True)

# Plot the MCA results for dimensions 1 and 3 on the second subplot
sns.scatterplot(
    ax=axes[1],
    x=mca_data[0],
    y=mca_data[2],
    hue=mca_data['poisonous'],
    palette=['green', 'red'],
    s=100,
    alpha=0.4
)
axes[1].set_xlabel('Dimension 1')
axes[1].set_ylabel('Dimension 3')
axes[1].legend(title='Mushroom Type')
axes[1].grid(True)

# Display the plots
plt.tight_layout()
plt.show()

											</code></pre>
										</div>
									</div>
									<br>
									<p>
										From the first MCA plot, we can see that while some clusters are well-defined, such as (1;0) and (1;7), others appear to overlap, 
										particularly in the bottom left corner (-0.5;0). This overlap suggests that this part of the data is not linearly separable. 
										To further investigate, we can introduce a third dimension, Dimension 3, and plot it against Dimension 1. In the second plot, 
										we observe that this large cluster is actually composed of smaller clusters, which still overlap but not as much as initially 
										thought. Overall, the MCA plot shows that although some clusters are clearly defined, others still overlap. Therefore, while 
										the entirety of the data is not linearly separable, a significant portion is, indicating that a non-linear model, such as a 
										Random Forest Classifier, would be a good choice for this dataset. We can also expect the model to have relatively high accuracy.
									</p>
									<hr />
									<h3 id="descmushp">Model</h3>

									<p>
										Now that we have a better understanding of the data, we can proceed with model building. We will use a Random Forest, a non-linear 
										model well-suited to this type of data. The Random Forest is an ensemble learning method that creates multiple decision trees and 
										combines their predictions to make a final prediction. This method is particularly useful for classification tasks and is known 
										for its high accuracy and robustness. We don't need to worry about many parameters; the dataset's documentation mentions achieving 
										99.8% accuracy with a single decision tree, so 10 trees should suffice to achieve near-perfect accuracy. We will train the model 
										using the usual 80% training data, 20% testing data split.

									</p>
									<div id="tab-container-5" class="tab-container">
										<div class="tabs">
											<button class="tab-link" onclick="openTab(event, 'Content9', 'tab-container-5')">Table</button>
											<button class="tab-link" onclick="openTab(event, 'Content10', 'tab-container-5')">Code</button>
										</div>
									
										<div id="Content9" class="tab-content">
											<p>Out of 1129 individuals tested, the model yields the following results:</p>
											<div class="table-wrapper">
												<table class="alt">
													<tr>
														<th></th>
														<th>Edible</th>
														<th>Poisonous</th>
													</tr>
													<tr>
														<td>Edible</td>
														<td>693</td>
														<td>0</td>
													</tr>
													<tr>
														<td>Poisonous</td>
														<td>0</td>
														<td>436</td>
													</tr>
												</table>
											<p>The model is 100.00% accurate.</p>
										</div>
									</div>

									<div id="Content10" class="tab-content">
										<pre class="language-python">
<code>from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import confusion_matrix

# Initialize label encoders
label_encoders = {}

# Encode all columns in X
for column in X.columns:
    le = LabelEncoder()
    X[column] = le.fit_transform(X[column])
    label_encoders[column] = le

# Encode the target variable y
le_y = LabelEncoder()
y = le_y.fit_transform(y)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=123)

# Initialize the Random Forest classifier with 10 trees
rf_classifier = RandomForestClassifier(n_estimators=10, random_state=123)

# Train the classifier
rf_classifier.fit(X_train, y_train)

# Predict on the test data
y_pred = rf_classifier.predict(X_test)

# Create a confusion matrix
conf_matrix = confusion_matrix(y_test, y_pred)

# Convert confusion matrix to DataFrame for better readability
conf_matrix_df = pd.DataFrame(conf_matrix, 
                              index=le_y.classes_, 
                              columns=le_y.classes_)

# Display the confusion matrix
print(f"Out of {len(y_test)} individuals tested, the model yields the following results:")

print(conf_matrix_df)

# Calculate the accuracy
accuracy = ((conf_matrix[0, 0] + conf_matrix[1, 1]) / conf_matrix.sum())*100
print(f"The model is {accuracy:.2f}% accurate.")</code>
										</pre>
									</div>
								</div>

								<hr />

								<H3 id="webmushp">Web App</H3>

								<p>
									To make the model accessible to everyone, we will create a web application that allows users to input the characteristics of a mushroom and 
									get a prediction of whether it is edible or poisonous. We will use the Dash Plotly framework to create the application. The application will 
									consist of a simple form where users can input the characteristics of the mushroom, and a button to submit the form. Once the form is submitted, 
									the application will use the trained Random Forest model to make a prediction and display the result to the user. The application was built using 
									Dash, hosted on Google Cloud, and can be accessed <a href="https://mushroom-roeb4awd7a-ew.a.run.app" target="_blank">here</a>.
								</p>

								<div id="tab-container-6" class="tab-container">
									<div class="tabs">
										<button class="tab-link" onclick="openTab(event, 'Content11', 'tab-container-6')">Web App</button>
										<button class="tab-link" onclick="openTab(event, 'Content12', 'tab-container-6')">Code</button>
									</div>
									<div id="Content11" class="tab-content">
										<iframe class="responsive-iframe" src="https://mushroom-roeb4awd7a-ew.a.run.app" width="940px" height="610px" frameborder="0" allowfullscreen></iframe>
									</div>
									<div id="Content12" class="tab-content">
										<pre class="language-python">
<code># Import necessary modules
import dash
import numpy as np
import plotly.graph_objects as go
from dash import dcc, html
from dash.dependencies import Input, Output, State
import io
import base64

# Initialize Dash app
app = dash.Dash(__name__)

# Design of the web app
(...)

# Callback to toggle sidebar visibility
@app.callback(
    Output('sidebar', 'style'),
    [Input('toggle-button', 'n_clicks')],
    [State('sidebar', 'style')]
)
def toggle_sidebar(n_clicks, sidebar_style):
    if n_clicks % 2 == 1:
        sidebar_style['display'] = 'block'
    else:
        sidebar_style['display'] = 'none'
    return sidebar_style

@app.callback(
    [
        Output('output-title', 'children'),
        Output('heatmap-output', 'figure')
    ],
    [Input('compute-button', 'n_clicks')],
    [
        State(f'dropdown-{variable}', 'value') for variable in X.columns
    ]
)
def update_output(n_clicks, *dropdown_values):
    selected_values = {variable: value for variable, value in zip(X.columns, dropdown_values)}

    if selected_values:
        X_test_mod = X_test.copy()
        for variable, value in selected_values.items():
            X_test_mod[variable] = value

        # Get predictions from each tree in the forest
        y_preds = [tree.predict(X_test_mod) for tree in rf_classifier.estimators_]

        # For simplicity, we visualize predictions for the first sample
        first_sample_predictions = np.array([pred[0] for pred in y_preds]).reshape(2, 5)

        # Determine overall prediction
        overall_prediction = np.round(np.mean(first_sample_predictions), 0).astype(int)
        if overall_prediction == 0:
            overall_prediction_label = html.Span(
                children=["😋", " This Mushroom is Edible ", "😋"],
                style={'color': 'green', 'font-size': '50px', 'font-family': 'Helvetica'}
            )
        else:
            overall_prediction_label = html.Span(
                children=["💀", " This Mushroom is Poisonous ", "💀"],
                style={'color': 'red', 'font-size': '50px', 'font-family': 'Helvetica'}
            )

        # Create a Plotly figure for the heatmap
        fig = go.Figure(data=go.Heatmap(
            z=first_sample_predictions,
            x=[f'Tree {i+1}' for i in range(5)],
            y=['Row 1', 'Row 2'],
            colorscale=[[0, 'green'], [1, 'red']],
            showscale=False,
            hoverinfo='text',
            zmin=0,
            zmax=1,
        ))

        # Define annotations for each tree
        annotations = []
        for i in range(2):
            for j in range(5):
                tree_number = ((i+1) * 5 + j + 1) %10
                if tree_number == 0:
                    tree_number = 10
                tree_value = first_sample_predictions[i, j]
                annotation_text = f'Tree {tree_number} <br><br> 😋' if tree_value == 0 else f'Tree {tree_number} <br><br> 💀'
                annotations.append(
                    dict(
                        x=j,
                        y=i,
                        xref='x',
                        yref='y',
                        text=annotation_text,
                        showarrow=False,
                        font=dict(family='Helvetica, sans-serif', size=40, color='white')
                    )
                )

        fig.update_layout(
            annotations=annotations,
            font=dict(family='Helvetica, sans-serif'),
            xaxis=dict(ticks='', showticklabels=False, showgrid=False, zeroline=False, showline=False),
            yaxis=dict(ticks='', showticklabels=False, showgrid=False, zeroline=False, showline=False),
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            margin=dict(l=0, r=0, t=0, b=0)
        )

        return overall_prediction_label, fig

    return "Select a Variable and Category", go.Figure()

# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)</code>
											</pre>
										</div>
									</div>	
									
									<p>
										The app is quite simple. Users can select the characteristics of a mushroom from the dropdown menus and click the "Compute" 
										button to get a prediction of whether the mushroom is edible or poisonous. The header of the app will display the prediction
										of the model and the heatmap will show the predictions of each tree in the Random Forest. The heatmap will display a green
										color if the tree predicts the mushroom is edible and a red color if the tree predicts the mushroom is poisonous.
									</p>

									<hr />

									<h3>Conclusion</h3>
									
									<p>
										And that concludes our analysis of the Mushroom dataset. We have successfully built a Random Forest model that can predict whether a mushroom is edible or poisonous with 100% accuracy. 
										We have also created a web application that allows users to input the characteristics of a mushroom and get a prediction of its toxicity. 
										We hope you enjoyed this analysis and learned something new. If you have any questions or comments, feel free to reach out to me. <br><br>
										Thank you for reading!
									</p>

									<hr />

									<h3>References</h3>
									<ul>
										<li><a href="https://archive.ics.uci.edu/ml/datasets/mushroom">UCI Machine Learning Repository: Mushroom Data Set</a></li>
										<li><a href="https://scikit-learn.org/stable/documentation.html">Scikit-learn Documentation</a></li>
										<li><a href="https://plotly.com/python/">Plotly Documentation</a></li>
										<li><a href="https://dash.plotly.com/">Dash Documentation</a></li>
									</ul>
								</div>
							</section>

				<!-- Footer -->
					<footer id="footer">
						<section>
							<form action="https://api.web3forms.com/submit" method="post" >
								<div class="fields">
									<input type="hidden" name="access_key" value="fa06f4c8-1867-47c9-8431-d971454af520">
									<div class="field">
										<label for="name">Name</label>
										<input type="text" name="name" id="name" required/>
									</div>
									<div class="field">
										<label for="email">Email</label>
										<input type="text" name="email" id="email" required/>
									</div>
									<div class="field">
										<label for="message">Message</label>
										<textarea name="message" id="message" rows="3" required></textarea>
									</div>
								</div>
								<ul class="actions">
									<li><input type="submit" value="send message" /></li>
								</ul>
							</form>
						</section>
						<section class="split contact">
							<section class="alt">
								<h3>Address</h3>
								<p>19 Rue du Mont Charvin<br />
								74230 Thônes, FRANCE</p>
							</section>
							<section>
								<h3>Phone</h3>
								<p><a href="#">(+33) 641-242-973</a></p>
							</section>
							<section>
								<h3>Email</h3>
								<p><a href="#">vittozcyprien@gmail.com</a></p>
							</section>
							<section>
								<h3>Social</h3>
								<ul class="icons alt">
									<li><a href="https://www.linkedin.com/in/vittozcyprien/" class="icon brands fa-linkedin" target="_blank"><span class="label">LinkedIn</span></a></li>
								</ul>
							</section>
						</section>
					</footer>

				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Cyprien Vittoz</li><li><a href="legal.html#header">Legal Mentions</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script>
				document.addEventListener("DOMContentLoaded", function() {
					Prism.highlightAll();
				});
			</script>
			<script src="assets/js/prism.js"></script>
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
	</body>
</html>